# 动态规划

动态规划，无非就是利用**历史记录**，来避免我们的重复计算。而这些**历史记录**，我们得需要一些**变量**来保存，一般是用**一维数组**或者**二维数组**来保存。

## 动态规划题很重要的三个步骤

### 第一步骤：数组元素的含义

上面说了，我们会用一个数组，来保存历史数组，假设用一维数组 dp [] 吧。这个时候有一个非常非常重要的点，就是规定你这个数组元素的含义，例如你的 dp [i] 是代表什么意思？

### 第二步骤：数组元素之间的关系式

我觉得动态规划，还是有一点类似于我们高中学习时的**归纳法**的，当我们要计算 dp [n] 时，是可以利用 dp [n-1]，dp [n-2]…..dp [1]，来推出 dp [n] 的，也就是可以利用**历史数据**来推出新的元素值，所以我们要找出数组元素之间的关系式，例如 dp [n] = dp [n-1] + dp [n-2]，这个就是他们的关系式了。而这一步，也是最难的一步

### 第三步骤：初始值

学过**数学归纳法**的都知道，虽然我们知道了数组元素之间的关系式，例如 dp [n] = dp [n-1] + dp [n-2]，我们可以通过 dp [n-1] 和 dp [n-2] 来计算 dp [n]，但是，我们得知道初始值啊，例如一直推下去的话，会由 dp [3] = dp [2] + dp [1]。而 dp [2] 和 dp [1] 是不能再分解的了，所以我们必须要能够直接获得 dp [2] 和 dp [1] 的值，而这，就是**所谓的初始值**。

由了**初始值**，并且有了**数组元素之间的关系式**，那么我们就可以得到 dp [n] 的值了，而 dp [n] 的含义是由你来定义的，你想**求什么，就定义它是什么**，这样，这道题也就解出来了。

关于初始值的定义: 我个人一般会先推出关系式,然后通过关系式逆推.再结合题目做个简单计算

比如. f[n] = f[n - 1] + f[n - 2];

那么n 就要大于1.不然就角标越界了.

结合题目就具体情况具体分析

## 习题

### 青蛙跳台阶

问题描述：一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

```java
   public static int jump(int n) {
        if (n < 1) {
            return -1;
        }
        int arr[] = new int[n + 1];
        arr[1] = 1;
        arr[2] = 2;

        for (int i = 3; i <= n; i++) {
            arr[i] = arr[i - 1] + arr[i - 2];
        }
        return arr[n];
    }
```

#### 关系式:

反问一下:

青蛙在什么位置可以跳到第N个位置.

n -1 位置   n-2位置

那么N    = (n -1)  + (n-2)

#### 初始值

根据题目可以推出:

楼梯数为0时:0步

楼梯数为1时:1步

当楼梯数为2时,带入公式:

2    = 1  + 0  不成立.那么2也得是初始值

楼梯数为2时:2步

当楼梯数为3时,带入公式:

3 = 1+ 2  ok

那么初始值 就是 0 1 2 ,也可以为 1 2 

 

### 机器人移动

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。

问总共有多少条不同的路径？(LeetCode 62题)

![4cf359d4-068b-11ea-be27-acde48001122](https://i.loli.net/2019/11/14/utOYWgy7hmAjq2E.png )

```java
public static int jq(int m, int n) {
    if (m <= 0 || n <= 0) {
        return 0;
    }
    int[][] arr = new int[m][n];
    for (int i = 0; i < m; i++) {
        arr[i][0] = 1;
    }
    for (int i = 0; i < n; i++) {
        arr[0][i] = 1;
    }

    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            arr[i][j] = arr[i - 1][j] + arr[i][j - 1];
        }
    }
    return arr[m - 1][n - 1];
}
```

#### 关系式

机器人在什么位置可以走到第m,n个位置.

f(m,n)  = f(m-1,n)+f(m,n-1)

#### 初始值

这个题的初始值 可以做如下思考:

机器人只能向下 和右 行走,那么 第一排 是不是无论走到那个位置 都是只有一种可能,一直向右走.

同理,第一列  无论到那个位置都是 一直向下走.





