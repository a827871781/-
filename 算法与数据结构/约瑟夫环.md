约瑟夫问题是个著名的问题：

N 个人围成一圈，第一个人从 1 开始报数，报 M 的将被杀掉，下一个人接着从 1 开始报。如此反复，最后剩下一个，求最后的胜利者。
例如只有三个人，把他们叫做 A、B、C，他们围成一圈，从 A 开始报数，假设报 2 的人被杀掉。

首先 A 开始报数，他报 1。侥幸逃过一劫。
然后轮到 B 报数，他报 2。非常惨，他被杀了
C 接着从 1 开始报数
接着轮到 A 报数，他报 2。也被杀死了。
最终胜利者是 C

```java
/**
 * @author syz
 */
public class Linked {


    public static void main(String[] args) {
        int m = 3;
        int n = 12;
        kickFromRing(m, n);
    }

    private static void kickFromRing(int m, int n) {
        Node head = creatHrNode(n);
        Node cur = head;
        int count = 0;
        Node temp = head;
        System.out.println("被删除的序列:");
        while (cur.getNext() != cur) {
            count++;
            if (count == m) {
                System.out.print(cur.getData());
                System.out.print(",");
                temp.setNext(cur.getNext());
                count = 0;
            }
            temp = cur;
            cur = cur.getNext();

        }
        System.out.println();
        System.out.println("答案为 : " + cur.getData());
    }


    /**
     * 构建 单项环形链表
     * 从 1 开始
     *
     * @param n 截止数字,包含 n
     * @return
     */
    private static Node creatHrNode(int n) {
        Node head = new Node(0 + 1);
        Node cur = head;
        Node temp;
        for (int i = 2; i < n + 1; i++) {
            temp = new Node(i);
            cur.setNext(temp);
            cur = temp;
        }
        cur.setNext(head);
        return head;
    }

}

class Node {
    private int Data;// 数据域
    private Node Next;// 指针域

    Node(int Data) {
        this.Data = Data;
    }

    int getData() {
        return Data;
    }

    public void setData(int Data) {
        this.Data = Data;
    }

    Node getNext() {
        return Next;
    }

    void setNext(Node Next) {
        this.Next = Next;
    }

    @Override
    public String toString() {
        return "Data = " + Data;
    }
}
```