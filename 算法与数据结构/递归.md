## 递归需要满足的三个条件 

只要同时满足以下三个条件，就可以用递归来解决。 

1.  一个问题的解可以分解为几个子问题的解 何为子问题?子问题就是数据规模更小的问题。
2.  这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
3.  存在递归终止条件 把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。 



**写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译**
**成代码。**

### 例子

斐波那契数列，又称黄金分割数列，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、…… 在数学上，斐波纳契数列以如下被以递归的方法定义：F（0）=0，F（1）=1，F（n）=F (n-1)+F (n-2)

```java
private int getFib(int n) {
  //终止条件开始
    if (n < 0) {
      return -1;
    }
    if (n == 0) {
      return 0;
    }
    if (n == 1 || n == 2) {
      return 1;
    }
  //终止条件结束  符合以上任意 都为终止条件
  
  //子问题
    return getFib(n - 1) + getFib(n - 2);
}
```



## 理解递归正确的思维方式

如果一个问题A可以分解为若干子问题B、C、D，你可以假设子问题B、C、D已经解决，在此基础上思考如何解决问题A。而且，你只需要思考问题A与子问 题B、C、D两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多 了。
因此，编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。

## 递归的优缺点

### 优点:

代码的表达力很强，写起来简洁。 

### 缺点:

空间复杂度高、有堆栈溢出风险、存在重复计算、过多的函数调用会耗时较多等问题。 

