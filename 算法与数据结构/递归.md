## 递归需要满足的三个条件 

只要同时满足以下三个条件，就可以用递归来解决。 

1.  **明确你这个函数想要干什么**
3.  **找出函数的等价关系式**  = 已知条件逆推 + 画图 + 经验
3.  **寻找递归结束条件**



**写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出函数的等价关系式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。**

### 斐波那契数列，又称黄金分割数列

指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、…… 在数学上，斐波纳契数列以如下被以递归的方法定义：**F（0）=0，F（1）=1，F（n）=F (n-1)+F (n-2)**

```java
public int getFib(int n) {
  //结束条件开始
    if (n < 0) {
      return -1;
    }
    if (n == 0) {
      return 0;
    }
    if (n == 1 || n == 2) {
      return 1;
    }
  //结束条件结束  符合以上任意 都为结束条件
  
  //等价关系式
    return getFib(n - 1) + getFib(n - 2);
}
```



## 理解递归正确的思维方式

如果一个问题A可以分解为若干子问题B、C、D，你可以假设子问题B、C、D已经解决，在此基础上思考如何解决问题A。而且，你只需要思考问题A与子问 题B、C、D两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多 了。
因此，编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。

## 递归的优缺点

### 优点:

代码的表达力很强，写起来简洁。 

### 缺点:

空间复杂度高、有堆栈溢出风险、存在重复计算、过多的函数调用会耗时较多等问题。 

## 习题

### 卖鸭子

一个人赶着鸭子去每个村庄卖，每经过一个村子卖去所赶鸭子的一半又一只。这样他经过了七个村子后还剩两只鸭子，问他出发时共赶多少只鸭子？经过每个村子卖出多少只鸭子

```java
    private static int answer(int n, int sum) {
        if (n <= 0) {
            return sum;
        }
        System.out.println(String.format("经过第%s个村子,此时还有鸭子%s个.", n, sum));
        return answer(--n, (sum + 1) * 2);
    }
```

#### 等价关系式:

这个题其实用一个坑,这个题 说的是经过 7个,其实应该说到达第八个村子时  还剩2 ,就比较好解释了

 x/2 - 1 = 2

得出公式

x= (2+1) / 2

#### 结束条件:

比较直观,所谓出发时,其实就是 没出村的时候么.

那么就是 n <= 0  么

### 青蛙跳台阶

一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

```java

public  int jump(int n) {
    //结束条件
    if (n < 1) {
        return -1;
    }
    if (n < 3) {
        return n;
    }
     //等价关系式
    return jump(n - 2) + jump(n - 1);
}
```

#### 等价关系式:

本题中,要跳到第N的台阶

那么先考虑 在哪个位置可以跳到 第N个台阶.

已知 一次可以跳 1  或 2 的台阶.

那么可以得出结论. 在 n-1 台阶处  和 n-2 台阶处 可以跳至 N 台阶

那么可以推导出公式为 : n = (n-1) + (n-2)   



#### 结束条件:

我一般结束条件基本主要看关系式,再结合题目.

本题中 等价关系式 n = (n-1) + (n-2)    

那么 就说明  N 就一定要对  n  等于 1 或 2  的 情况进行处理.

那么 就得出 

`if (n < 3) {
        return n;
    }`

根据题目跳台阶,那么 台阶数 就不能小于 1 么.  

### 反转单链表

反转单链表。例如链表为：1->2->3->4。反转后为 4->3->2->1

```java

class TestNode {
    int date;
    TestNode next;

    TestNode(int value) {
        this.date = value;
    }
}

public static TestNode reverseNode(TestNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    TestNode newList = reverseNode(head.next);
    TestNode temp = head.next;
    head.next = null;
    temp.next = head;
    return newList;
}

```

#### 等价关系式:

暂不知.此题 我是从答案逆推的.

 1 2 3 4  转  4 3 2 1

那么就先将 1234 压栈, 然后弹出 4321,再反复尝试的.

所以啊,此题 就记一下大概解题思路. 

#### 结束条件:

开始  我猜测 结束条件 大概率是如下代码,一般链表的结束条件 都是这个

```java
if (head == null ) {
    return head;
}
```
做了一下 发现 可能会空指针

就改成这样,避免空指针

```java
if (head == null || head.next == null) {
    return head;
}	
```
