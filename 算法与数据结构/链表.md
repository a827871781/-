

## 什么是链表

链表 [Linked List]：链表是由一组不必相连【不必相连：可以连续也可以不连续】的内存结构 【节点】，按特定的顺序链接在一起的抽象数据类型。

## 常见链表

链表常用的有 3 类：

### 单链表

由各个内存结构通过一个 `Next` 指针链接在一起组成，每一个内存结构都存在后继内存结构【链尾除外】，内存结构由数据域和 `Next` 指针域组成。

### 双向链表

由各个内存结构通过指针 `Next` 和指针 `Prev` 链接在一起组成，每一个内存结构都存在前驱内存结构和后继内存结构【链头没有前驱，链尾没有后继】，内存结构由数据域、Prev 指针域和 Next 指针域组成。

### 循环链表

#### 单向循环链表

由各个内存结构通过一个指针 `Next` 链接在一起组成，每一个内存结构都存在后继内存结构，内存结构由数据域和 Next 指针域组成。

#### 双向循环链表

由各个内存结构通过指针 `Next` 和指针 `Prev` 链接在一起组成，每一个内存结构都存在前驱内存结构和后继内存结构，内存结构由数据域、Prev 指针域和 Next 指针域组成。



## 链表常见题

### 单链表反转 

```java
/**
 * 单链表反转 
 * 结题思路:
 * 将cur链表中的头节点 取出,作为新的链表的头结点
 * 顺序: 前面为新的链表, 后面的是原有链表
 * 初始状态: 新的: 无    原来:123456
 * 以下是每次循环结果:  空格左为新链表 ,右为 原有链表
 * 1 23456
 * 21 3456
 * 321 456
 * 4321 456
 * 54321 6
 * 654321
 *
 * @param head
 * @return
 */
private static Node reverseByLoop(Node head) {
  if (head == null || head.next == null) {
    return head;
  }
  Node newNode = null;
  Node curNode = head;
  Node tempNode = null;
  while (curNode != null) {
    tempNode = curNode.next;
    System.out.println("临时链表状态:");
    printList(tempNode);


    curNode.next = newNode;
    System.out.println("当前链表状态:");
    printList(curNode);

    newNode = curNode;
    curNode = tempNode;

    System.out.println("一次循环结束");
    System.out.println();
    System.out.println();
  }
  return newNode;
}
```



### 链表中环的检测

```java
/**
 * 判断链表是否有环 采用快慢指针
 * 若有环，快指针先行进环，在环中绕圈，慢指针后入环，也在环中绕圈，
 * 由于快指针每次比慢指针多走一步，意味着两个指针在环中的位置每次都缩短一步，
 * 所以若有环，两个指针在环中必能相遇
 * 如: 1 - 2 - 3 - 4 -2  如此一个环
 * 慢指针遍历:1 2 3
 * 快指针遍历:2 4 3
 * 此时 快慢指针相遇  那么证明 存在环,返回true
 *
 * @param head
 * @return
 */
public boolean hasCycle(Node head) {
    if (head == null) {
      return false;
    }
    Node slow = head;
    Node fast = head.next;
    while (fast.next != null && fast != null) {
      if (slow == fast) {
        return true;
      }
      slow = slow.next;
      fast = fast.next.next;
    }
    return false;
}
```

### 约瑟夫环

```java
/**
 * 约瑟夫环
 * 结题思路:
 * 就按着题目说的遍历-判断-删除即可.
 *
 * @param head
 * @param m
 * @param n
 */
private static void kickFromRing(Node head, int m, int n) {
    Node cur = head;
    int count = 0;
    Node temp = head;
    System.out.println("被删除的序列:");
    while (cur.next != cur) {
        count++;
        if (count == m) {
            System.out.print(cur.value);
            System.out.print(",");
            temp.next = cur.next;
            count = 0;
        }
        temp = cur;
        cur = cur.next;

    }
    System.out.println();
    System.out.println("答案为 : " + cur.value);
}
```

### 两个有序的链表合并

暂无

### 删除链表倒数第n个结点

暂无

### 求链表的中间结点 

暂无



## 完整代码

```java
/**
 * @author: syz
 * @Date: 2019/11/5
 */
public class ReLinkdeList {


    /**
     * 结题思路:
     * 将cur链表中的头节点 取出,作为新的链表的头结点
     * 顺序: 前面为新的链表, 后面的是原有链表
     * 初始状态: 新的: 无    原来:123456
     * 以下是每次循环结果:  空格左为新链表 ,右为 原有链表
     * 1 23456
     * 21 3456
     * 321 456
     * 4321 456
     * 54321 6
     * 654321
     *
     * @param head
     * @return
     */
    private static Node reverseByLoop(Node head) {
        if (head == null || head.next == null) {
            return head;
        }
        Node newNode = null;
        Node curNode = head;
        Node tempNode = null;
        while (curNode != null) {
            tempNode = curNode.next;
            System.out.println("临时链表状态:");
            printList(tempNode);


            curNode.next = newNode;
            System.out.println("当前链表状态:");
            printList(curNode);

            newNode = curNode;
            curNode = tempNode;

            System.out.println("一次循环结束");
            System.out.println();
            System.out.println();
        }
        return newNode;
    }

    /**
     * 约瑟夫环
     * 结题思路:
     * 就按着题目说的遍历即可.
     *
     * @param head
     * @param m
     * @param n
     */
    private static void kickFromRing(Node head, int m, int n) {
        Node cur = head;
        int count = 0;
        Node temp = head;
        System.out.println("被删除的序列:");
        while (cur.next != cur) {
            count++;
            if (count == m) {
                System.out.print(cur.value);
                System.out.print(",");
                temp.next = cur.next;
                count = 0;
            }
            temp = cur;
            cur = cur.next;

        }
        System.out.println();
        System.out.println("答案为 : " + cur.value);
    }


    /**
     * 判断链表是否有环 采用快慢指针
     * 若有环，快指针先行进环，在环中绕圈，慢指针后入环，也在环中绕圈，
     * 由于快指针每次比慢指针多走一步，意味着两个指针在环中的位置每次都缩短一步，
     * 所以若有环，两个指针在环中必能相遇
     * 如: 1 - 2 - 3 - 4 -2  如此一个环
     * 慢指针遍历:1 2 3
     * 快指针遍历:2 4 3
     * 此时 快慢指针相遇  那么证明 存在环,返回true
     *
     * @param head
     * @return
     */
    public boolean hasCycle(Node head) {
        if (head == null) {
            return false;
        }
        Node slow = head;
        Node fast = head.next;
        while (fast.next != null && fast != null) {
            if (slow == fast) {
                return true;
            }
            slow = slow.next;
            fast = fast.next.next;
        }
        return false;
    }


    private static void printList(Node root) {
        if (root == null) {
            System.out.println("链表为空");
            return;
        }
        Node cur = root;
        while (cur != null) {
            System.out.print(cur.value);
            System.out.print(" ");
            cur = cur.next;
        }
        System.out.println();
    }

    private static Node creatNode(String str) {
        Node root = new Node(str.charAt(0));
        Node pre = root;
        char[] chars = str.toCharArray();
        for (int i = 1; i < chars.length; i++) {
            Node node = new Node(chars[i]);
            pre.next = node;
            pre = node;
        }
        return root;
    }


    static class Node {
        Character value;
        Node next;

        Node(Character value) {
            this.value = value;
        }
    }
}

```



















