# 概述

## 为什么要优化

- 系统的吞吐量瓶颈往往出现在数据库的访问速度上
- 随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢
- 数据是存放在磁盘上的，读写速度无法和内存相比

## 如何优化

- 设计数据库时：数据库表、字段的设计，存储引擎
- 利用好MySQL自身提供的功能，如索引等
- 横向扩展：MySQL集群、负载均衡、读写分离
- SQL语句的优化

### 建表原则

1. 尽量选择小的数据类型，数据类型选择上尽量tinyint(1字节)>smallint(2字节)>int(4字节)>bigint(8字节)，比如逻辑删除yn字段上（1代表可用，0代表）就可以选择tinyint（1字节）类型
2. 尽量保证字段数据类型长度固定
3. 尽量避免使用null，使用null的字段查询很难优化，影响索引，可以使用0或""代替
4. 避免宽表，能拆分就拆分，一个表往往跟一个实体域对应，就像设计对象的时候一样，保持单一原则
5. 尽量避免使用text和blob，如果非使用不可，最好将类型为text和blob的字段在独立成一张新表，然后使用主键对应原表
6. 避免使用float或double类型，这个坑超大，float或double存在精度问题，在进行比较或者加减操作的时候会丢失精度导致数据异常，凡是使用float或double类型的时候考虑下可不可使用int或bigint代替。比如金额，以元为单位使用float或double类型的时候，可以考虑以分为单位使用int，bigint类型代替，然后由业务代码进行单位的转换。
7. 预留字段,冗余字段,原则上不建议使用,但是业务优先.
8. 每张表都加上createUser,createTime.updateUser,updateTime字段
9. 起名字要规范，包括：库名，表名，字段名，索引名
10. 查询频繁使用的字段记得加索引
11. 尽量避免使用外键，不用外键约束，性能更高，然后数据的完整性有程序进行管理
12. 如果表的数量可以预测到非常大，最好在建表的时候，就进行分表，不至于一时间数据量非常大导致效率问题



### 创建使用索引的原则

1. 索引的字段尽量要小，根据索引查询数据的快慢取决于b tree的高度，当数据量恒定的时候，字节越少，存的索引的数量就越多，树的高度就越会越低
2. 如果索引字段的值很长，最好使用值的前缀来索引
3. 遵循索引的最左匹配原则
4. 利用好覆盖索引.
5. 注意使用like的时候尽量不要使用“%a%”，这样的不走索引，可以使用“a%”，走索引
6. 不要在索引的列上进行计算，比如 select * from sys_user where token_expire+1 = 10000，这样的语句 不会走有索引
7. 索引字段列的类型要和where 条件的一致,避免发生隐式的类型转化
8. 什么样的字段建索引，就是那种频繁在where，group by，order by  中出现的列，最好加上索引
9. 限制索引的数目,合理添加索引,越多的索引会使更新表变得很慢



### 优化的建议

#### 1. 查询的时候一定要记得使用limit或rownum进行限制

​		尽量保证不要出现大的offset，比如limit 10000,10相当于对已查询出来的行数弃掉前10000行后再取10行，完全可以加一些条件过滤一下（完成筛选），而不应该使用limit跳过已查询到的数据。这是一个**offset做无用功**的问题。对应实际工程中，要避免出现大页码的情况，尽量引导用户做条件过滤。

#### 2.limit 1

如果可以确定仅仅检索一条，建议加上limit 1，其实ORM框架帮我们做到了这一点（查询单条的操作都会自动加上limit 1）。

#### 3.不要使用select * 来查数据，使用select 需要的列名，这样的方式去查询

​		即尽量选择自己需要的字段select，但这个影响不是很大，因为网络传输多了几十上百字节也没多少延时，并且现在流行的ORM框架都是用的select  *，只是我们在**设计表的时候注意将大数据量的字段分离**，比如商品详情可以单独抽离出一张商品详情表，这样在查看商品简略页面时的加载速度就不会有影响了。

#### 4.单表和多表查询

多表查询：join、子查询都是涉及到多表的查询。如果你使用explain分析执行计划你会发现多表查询也是一个表一个表的处理，最后合并结果。因此可以说单表查询将计算压力放在了应用程序上，而多表查询将计算压力放在了数据库上。

现在有ORM框架帮我们解决了单表查询带来的对象映射问题（查询单表时，如果发现有外键自动再去查询关联表，是一个表一个表查的）。

#### 5.优先使用count (1)、count (*) 

1、`count(1)`  and  `count(*)` MySQL 官方文档这么说：

>   InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference.

所以，对于 `count(1)` 和 `count(*)`，MySQL 的优化是完全一样的，根本不存在谁更快！

但依旧建议使用 `count(*)`，因为这是 SQL92 定义的标准统计行数的语法。

2、`count (1)` and `count (字段)`
两者的主要区别是
`count (1)` 会统计表中的所有的记录数，包含字段为 null 的记录。
`count (字段)` 会统计该字段在表中出现的次数，忽略字段为 null 的情况。即不统计字段为 null 的记录。

3、`count (*) `和` count (1)` 和 `count (列名)` 区别
  **执行效果：**

-   `count (*) ` 包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为 NULL。

-   `count (1)` 包括了忽略所有列，用 1 代表代码行，在统计结果的时候，不会忽略列值为 NULL 。

-   `count (列名) ` 只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者 0，而是表示 null）的计数，即某个字段值为 NULL 时，不统计。

    **执行效率：**

-   列名为主键，`count (列名) `会比 `count (1) `快。

-   列名不为主键，`count (1) `会比 `count (列名) `快。

-   如果表多个列并且没有主键，则 `count（1）` 的执行效率优于` count（\*）`。

-   如果有主键，则 `select count（主键）`的执行效率是最优的。

-   如果表只有一个字段，则 `select count（\*）`最优。

    **执行速度：**

     `count(*) ` = `count(1)` > `count(列名)`

#### 5.order by rand()不要用

它的逻辑就是随机排序（为每条数据生成一个随机数，然后根据随机数大小进行排序）。如select * from student order by rand() limit 5的执行效率就很低，因为它为表中的每条数据都生成随机数并进行排序，而我们只要前5条。

解决思路：在应用程序中，将随机的主键生成好，去数据库中利用主键检索。

#### 6.慢查询日志

用于记录执行时间超过某个临界值的SQL日志，用于快速定位慢查询，为我们的优化做参考。

##### 开启慢查询日志

配置项：slow_query_log

可以使用show variables like ‘slov_query_log’查看是否开启，如果状态值为OFF，可以使用set GLOBAL slow_query_log = on来开启，它会在datadir下产生一个xxx-slow.log的文件。

#### 7.设置临界时间

配置项：long_query_time

查看：show VARIABLES like 'long_query_time'，单位秒

设置：set long_query_time=0.5

实操时应该从长时间设置到短的时间，即将最慢的SQL优化掉

#### 8.查看日志

一旦SQL超过了我们设置的临界时间就会被记录到xxx-slow.log中

#### 9.profile信息

配置项：profiling

**开启profile**

set profiling=on

开启后，所有的SQL执行的详细信息都会被自动记录下来

#### 10.通过Query_ID查看某条SQL所有详细步骤的时间

show profile for query Query_ID

上面show profiles的结果中，每个SQL有一个Query_ID，可以通过它查看执行该SQL经过了哪些步骤，各消耗了多场时间

#### 11.sql查询缓存相关

不要用，如果要缓存，那么就在代码内使用缓存。

