###  一条`SQL`查询语句是如何执行的

![page1](https://github.com/a827871781/Java-notes/blob/master/images/1.png)

### 一条SQL更新语句是如何执行的

1. 执行器先找引擎查询的数据。引擎直接用树搜索找到这一行。如果这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
2. 执行器拿到引擎给的行数据，把这个值更新，得到新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。
4. 执行器生成这个操作的`binlog`，并把`binlog`写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。

**两种日志区别**

酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。

如果有人要赊账或者还账的话，掌柜一般有两种做法：

- `binlog`：一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；
- `redo log`：另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。

1. `redo log`是`InnoDB`引擎特有的；`binlog`是`MySQL`的`Server`层实现的，所有引擎都可以使用。
2. `redo log`是物理日志，记录的是“在某个数据页上做了什么修改”；`binlog`是逻辑日志，记录的是这个语句的原始逻辑，比如`“给ID=2这一行的c字段加1 ”`。
3. `redo log`是循环写的，空间固定会用完；`binlog`是可以追加写入的。“追加写”是指`binlog`文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。`

`注：不建议在mysql内使用缓存，如果有需要做缓存，在应用层加入。并且mysql在8版本以后也去除掉了缓存`

### 讲事务隔离：事务隔离的实现

在`MySQL`中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。

![](https://github.com/a827871781/Java-notes/blob/master/images/2.png)

在查询这条记录的时候，不同时刻启动的事务会有不同的版本视图。如图中看到的，在版本A、B、C、D里面，这一个记录的值分别是1、2、3、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（`MVCC`）。对于版本 A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。

**基于上面的说明**
长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，所以建议尽量不要使用长事务。

### 索引

什么是索引：为了提高数据查询的效率，概念类似书的目录。

#### 索引的常见模型

索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了索引模型的概念。可以用于提高读写效率的数据结构很多，分别是哈希表、有序数组和搜索树。

**哈希表**是一种以键-值（key-value）存储数据的结构,概念等同于`Hashmap`,哈希表这种结构适用于只有等值查询的场景

**有序数组**在等值查询和范围查询场景中的性能就非常优秀,查询和删除效率等同于List

**二叉搜索树**特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。查询 更新都是O(log(N)

二叉树是搜索效率最高的但数据库存储不使用二叉树，因为索引不止在内存也在磁盘。

你可以想象一下一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要10 ms左右的寻址时间。也就是说，对于一个100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10 ms的时间，这个查询可真够慢的。

为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N叉”树。这里，“N叉”树中的“N”取决于数据块的大小。

以`InnoDB`的一个整数字段索引为例，这个N差不多是1200。这棵树高是4的时候，就可以存1200的3次方个值，这已经17亿了。考虑到树根的数据块总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了

**N叉树（多路平衡查找树 、B树）**在读写上的性能优异，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中

#### B+树

- 从根节点到叶节点的所有路径都具有相同的长度
- 所有数据信息都存储在叶节点上，非叶节点仅作为叶节点的索引存在
- 根结点至少拥有两个键值对
- 每个树节点最多拥有M个键值对
- 每个树节点（除了根节点）拥有至少M/2个键值对



#### `InnoDB `的索引模型

在`InnoDB`中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。`InnoDB`使用了**B+树索引模型**，所以数据都是存储在B+树中的。

把整颗树的高度维持在很小的范围内，同时在内存里缓存前面若干层的节点，可以极大地降低访问磁盘的次数，提高读的效率。

B+树的插入可能会引起数据页的分裂，删除可能会引起数据页的合并，二者都是比较重的IO消耗，所以比较好的方式是顺序插入数据，这也是我们一般使用自增主键的原因之一。

#### 索引类型：

主键索引、非主键索引

主键索引的叶子节点存的是整行的数据(聚簇索引)，非主键索引的叶子节点内容是主键的值(二级索引)

普通索引查询方式，则需要先搜索普通索引树，得到主键值，再到主键索引树搜索一次。这个过程称为回表。

基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。

N叉树的N值在`MySQL`中是可以被人工调整的么？

5.6以后可以通过page大小来间接控制

#### 覆盖索引

如果执行的语句是select ID from T where k between 3 and 5，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为**覆盖索引**。

由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。

#### 最左前缀原则

B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录

1、覆盖索引：如果查询条件使用的是普通索引（或是联合索引的最左原则字段），查询结果是联合索引的字段或是主键，不用回表操作，直接返回结果，减少IO磁盘读写读取正行数据
2、最左前缀：联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符
3、联合索引：根据创建联合索引的顺序，以最左原则进行where检索，比如（age，name）以age=1 或 age= 1 and name=‘张三’可以使用索引，单以name=‘张三’ 不会使用索引，考虑到存储空间的问题，还请根据业务需求，将查找频繁的数据进行靠左创建索引。
4、索引下推：like 'hello%’and age >10 检索，`MySQL5.6`版本之前，会对匹配的数据进行回表查询。5.6版本后，会先过滤掉age<10的数据，再进行回表查询，减少回表率，提升检索速度