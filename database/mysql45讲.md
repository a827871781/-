###  一条`SQL`查询语句是如何执行的

![page1](C:\Users\Administrator\Desktop\page1.png)

### 一条SQL更新语句是如何执行的

1. 执行器先找引擎查询的数据。引擎直接用树搜索找到这一行。如果这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
2. 执行器拿到引擎给的行数据，把这个值更新，得到新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。
4. 执行器生成这个操作的`binlog`，并把`binlog`写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。

**两种日志区别**

酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。

如果有人要赊账或者还账的话，掌柜一般有两种做法：

- `binlog`：一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；
- `redo log`：另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。

1. `redo log`是`InnoDB`引擎特有的；`binlog`是`MySQL`的`Server`层实现的，所有引擎都可以使用。
2. `redo log`是物理日志，记录的是“在某个数据页上做了什么修改”；`binlog`是逻辑日志，记录的是这个语句的原始逻辑，比如`“给ID=2这一行的c字段加1 ”`。
3. `redo log`是循环写的，空间固定会用完；`binlog`是可以追加写入的。“追加写”是指`binlog`文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。`

`注：不建议在mysql内使用缓存，如果有需要做缓存，在应用层加入。并且mysql在8版本以后也去除掉了缓存`

### 讲事务隔离：事务隔离的实现

在`MySQL`中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。

![](C:\Users\Administrator\Desktop\2.png)

在查询这条记录的时候，不同时刻启动的事务会有不同的版本视图。如图中看到的，在版本A、B、C、D里面，这一个记录的值分别是1、2、3、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（`MVCC`）。对于版本 A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。

**基于上面的说明**
长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，所以建议尽量不要使用长事务。