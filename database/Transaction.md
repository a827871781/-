### 一、什么是事务

**事务是访问数据库的一个操作序列，数据库应用系统通过事务集来完成对数据库的存取。事务的正确执行使得数据库从一种状态转换为另一种状态。**

**事务必须服从ISO/IEC所制定的ACID原则。ACID是原子性（`atomicity`）、一致性（`consistency`）、隔离性（`isolation`）、持久性（`durability`）的缩写，这四种状态的意思是：**

### 二、事务的基本要素（`ACID`）

　　**1、原子性（`Atomicity`）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。**

　　 **2、一致性（`Consistency`）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。**

　　 **3、隔离性（`Isolation`）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。**

　　 **4、持久性（`Durability`）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。**
**事务的实现**

事务的原子性是通过 undo log(回滚日志) 来实现的
事务的持久性性是通过 redo log(重做日志) 来实现的
事务的隔离性是通过 (读写锁 + `MVCC`) 来实现的
而事务的终极大 boss **一致性**是通过原子性，持久性，隔离性来实现的！！！
原子性，持久性，隔离性折腾半天的目的也是为了保障数据的一致性！

总之，ACID 只是个概念，事务最终目的是要保障数据的可靠性，一致性。
### 三、事务的并发问题

　　**1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据**

　　**2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。**

　　**3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。**

　　**小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表**

### 四、MySQL事务隔离级别

| 事务隔离级别                 | 脏读  | 不可重复读 | 幻读 |
| ---------------------------| ---- | ---------- | ---- |
| 读未提交（`read-uncommitted`） | 是   | 是         | 是   |
| 读已提交（`read-committed`） | 否   | 是         | 是   |
| 重复读取（`repeatable-read`） | 否   | 否         | 是   |
| 串行化（`serializable`） | 否   | 否         | 否   |

- **事务隔离级别为读未提交时，写数据只会锁住相应的行**
- **事务隔离级别为读已提交时，如果检索条件有索引（包括主键索引）的时候，默认加锁方式是next-key 锁；如果检索条件没有索引，更新数据时会锁住整张表。一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的，这样可以防止幻读。**
- **事务隔离级别为重复读取时,sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了，保证可重复读，**
- **事务隔离级别为串行化时，读写数据都会锁住整张表**
- **隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。**
- **SqlServer、oracle 默认级别为读已提交，mysql默认级别为重复读取。**

| 事务隔离级别                   | select | insert、update、delete |
| :----------------------------- | ------ | ---------------------- |
| 读未提交（`read-uncommitted`） | 无锁   | 无锁                   |
| 读已提交（`read-committed`）   | 无锁   | 有索引行锁、无索引表锁 |
| 重复读取（`repeatable-read`）  | 行锁   | 有索引行锁、无索引表锁 |
| 串行化（`serializable`）       | 共享锁 | 排他锁                 |

**共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。也就是说只能读不能写**



**排他锁又称写锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。只能自己写。**



### 五、Spring 事务的传播属性

所谓spring事务的传播属性，就是定义在存在多个事务同时存在的时候，spring应该如何处理这些事务的行为。这些属性在TransactionDefinition中定义，具体常量的解释见下表：

| 常量名称              		| 常量解释   							   |
| ------------------------- | :----------------------------------------------: |
| `PROPAGATION_REQUIRED` | 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择，也是 Spring 默认的事务的传播。 |
| `PROPAGATION_REQUIRES_NEW` | 新建事务，如果当前存在事务，把当前事务挂起。新建的事务将和被挂起的事务没有任何关系，是两个独立的事务，外层事务失败回滚之后，不能回滚内层事务执行的结果，内层事务失败抛出异常，外层事务捕获，也可以不处理回滚操作 |
| `PROPAGATION_SUPPORTS` | 支持当前事务，如果当前没有事务，就以非事务方式执行。         |
| `PROPAGATION_MANDATORY` | 支持当前事务，如果当前没有事务，就抛出异常。                 |
| `PROPAGATION_NOT_SUPPORTED` | 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。   |
| `PROPAGATION_NEVER` | 以非事务方式执行，如果当前存在事务，则抛出异常。             |
| `PROPAGATION_NESTED` | 如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效。 |

### 六、跨库事务（2pc）

一个应用或者说服务，同时访问两个数据库，这个时候就需要跨库事务 。

跨库事务通常采用 2PC 协议，全称 Two Phase Commitment Protocol。该协议主要为了解决在分布式数据库场景下，所有节点间数据一致性的问题。分布式事务通过 2PC 协议将提交分成两个阶段：

1. **prepare**；

2. **commit/rollback**

​        阶段一为准备（prepare）阶段。即所有的参与者准备执行事务并锁住需要的资源。参与者 ready 时，向 transaction manager 报告已准备就绪。 
阶段二为提交阶段（commit）。当 transaction manager 确认所有参与者都 ready 后，向所有参与者发送 commit 命令。 

本地事务:就是啥我都自己管。

2pc: 就是把多库的事务管理起来，执行sql时将相关库的事务拉的很长，然后 都行了 就commit 有一个不行 就callback。

具体内容google 太多了。这里不详细解释

参考代码

[spring-2pc](https://github.com/a827871781/springboot-2pc/tree/master)

### 七、分布式事务

简单的说就是在微服务中应用的事务方案。

SpringCloud 或 Dubbo  这种微服务框架 才用的上

#### 分布式事务的解决方案有如下几种：

##### **基于可靠消息服务的分布式事务（异步确保型）**

- 这种实现分布式事务的方式需要通过消息中间件来实现。假设有A和B两个系统，分别可以处理任务A和任务B。此时系统A中存在一个业务流程，需要将任务A和任务B在同一个事务中处理。

- 在系统A处理任务A前，首先向消息中间件发送一条消息

- 消息中间件收到后将该条消息持久化，但并不投递。此时下游系统B仍然不知道该条消息的存在。

- 消息中间件持久化成功后，便向系统A返回一个确认应答；

- 系统A收到确认应答后，则可以开始处理任务A；

- 任务A处理完成后，向消息中间件发送Commit请求。该请求发送完成后，对系统A而言，该事务的处理过程就结束了，此时它可以处理别的任务了。 但commit消息可能会在传输途中丢失，从而消息中间件并不会向系统B投递这条消息，从而系统就会出现不一致性。这个问题由消息中间件的事务回查机制完成，下文会介绍。

- 消息中间件收到Commit指令后，便向系统B投递该消息，从而触发任务B的执行；

- 当任务B执行完成后，系统B向消息中间件返回一个确认应答，告诉消息中间件该消息已经成功消费，此时，这个分布式事务完成。

缺点：mq高可用，需要回滚的话，就需要让系统A事先提供回滚接口

##### **主要是用“记录”和“补偿”的方式。**

​	在做所有的不确定的事情之前，先把事情记录下来，然后去做不确定的事情，结果可能是：成功、失败或是不确定，“不确定”（例如超时等）可以等价为失败。成功就可以把记录的东西清理掉了，对于失败和不确定，可以依靠定时任务等方式把所有失败的事情重新搞一遍，直到成功为止。

##### `TCC（补偿型 重点，这个最为常用）`

​	**Try**: 主要是对业务系统做检测及资源预留。

​	**Confirm**:阶段主要是对业务系统做确认提交，

​	**Cancel**:阶段主要执行的就是解冻释放我们扣减的资源预留 ，

###### 业务场景

库存服务-库存数量是 100，

 - 在`TCC`事务中TRY阶段，库存数量 =  100 - 2 = 98，在一个单独的冻结库存的字段里，设置一个 2。也就是说，有 2 个库存是给冻结了

 - 如果在TRY阶段，任何一个服务失败，tcc-transaction将自动调用这些服务对应的cancel方法，就是将冻结库存扣减掉 2，加回到可销售库存里去，98 + 2 = 100。

 - 如果TRY阶段正常完成，则进入Confirm阶段，在Confirm阶段（tcc-transaction自动调用）,将之前冻结库存字段的 2 个库存扣掉变为 0。


国内开源的`TCC框架 ByteTCC、Himly、TCC-transaction`。

TCC适用于对一致性、实时性要求较高的业务场景

缺点：TCC的Try、Confirm和Cancel操作功能需业务提供，开发成本高。

**这里有个坑，就是接口设计一定要幂等，框架封装请求时大部分都有重试机制。万一在sql中写类似 X++ 的代码可能会引发问题**

###### 最大努力通知

主要也是借助`MQ`消息系统来进行事务控制，这一点与可靠消息最终一致方案一样。最大努力通知方案是比较简单的分布式事务方案，它本质上就是通过定期校对，适用于数据一致性时间要求不太高的场合。
一.最大努力通知方案的实现

1. 业务活动的主动方，在完成业务处理之后，向业务活动的被动方发送消息，允许消息丢失。
2. 主动方可以设置时间阶梯型通知规则，在通知失败后按规则重复通知，直到通知N次后不再通知。
3. 主动方提供校对查询接口给被动方按需校对查询，用于恢复丢失的业务消息。
4. 业务活动的被动方如果正常接收了数据，就正常返回响应，并结束事务。
5. 如果被动方没有正常接收，根据定时策略，向业务活动主动方查询，恢复丢失的业务消息。

二.最大努力通知方案的设计

1. 实时消息服务（`MQ`）：接收主动方发送的`MQ`消息。
2. 通知服务子系统：监听`MQ`消息，当收到消息后，向被动方发送通知（一般是URL方式），同时生成通知记录
3. 如果没有接收到被动方的返回消息，就根据通知记录进行重复通知。

基本可用，最终一致。




