## redis相关

**redis内部机制：**

- 纯内存操作。
- 单线程操作，避免频繁的上下文切换。
- 采用非阻塞的IO多路复用机制

**redis的数据类型：**

String、hash、list（底层双向链表）、set、sorted set

**redis的过期策略以及内存淘汰机制：**

redis采用的是定期删除+惰性删除策略。

定期删除：每100ms随机抽取进行检查过期key

惰性删除：获取key的时候，redis会检查一下，过期则删除。

内存淘汰机制：有多种机制，通常使用allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。

**redis功能：**

分布式锁，分布式id，模拟注册中心，模拟队列，分布式session，缓存。

**redis持久化：**

AOP：基于日志，启动redis时读取日志，可能会因为日志文件过大导致读取很慢。

RDB：异步处理，每隔一段时间，将内存中的数据作为一个快照文件（snapshot）写入到磁盘，启动读取快，可能会丢失数据。

**缓存穿透和缓存雪崩问题：**

缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。

1、采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作

2、利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效



缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。

1、给缓存的失效时间，加上一个随机值，避免集体失效

2、双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。

1. 从缓存A读数据库，有则直接返回
2. A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。
3. 更新线程同时更新缓存A和缓存B。

**redis和数据库双写一致性问题：**

先删缓存，在更数据库，可能会在删除缓存之后，大量请求访问，造成缓存穿透。

处理方案，更新数据库后，异步启动线程更新缓存。

**解决redis的并发竞争key**

1、不要求顺序

这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。

2、要求顺序

带版本号更新，key存储key 版本，通过版本比较，大于才更新value及版本值

**同类型缓存比较：**

memcache：基于内存，无法持久化，单个文件最大1M，可存储图片视频。

Ehcache：ehcache直接在jvm虚拟机中缓存，速度快，效率高；但是缓存共享麻烦，集群分布式应用不方便。单体应用适合Ehcache