### JVM 

#### JVM启动流程

1. 配置 JVM 装载环境 
2. 解析虚拟机参数 
3. 设置线程栈大小 
4. 执行 Java main 方法

#### JVM基本结构

![](https://cdn.sinaimg.cn.52ecy.cn/large/005BYqpgly1g47uhopk50j30ob0e97cr.jpg)

##### PC寄存器（程序计数器）

- 每个线程拥有一个PC寄存器
- 在线程创建时创建
- 指向下一条指令的地址
- 执行本地方法时，PC的值为undefined
- 此内存区是唯一不会抛出 OutOfMemoryError 的区域。

##### 方法区

- 保存装载的类信息

  - 类型的常量池
  - 类名、修饰符
  - 静态变量、构造函数
  - 字段，方法信息
  - 方法字节码
  - 运行时常量池（用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进人方法区的运行时常量池中存放。）
- 在HotSpot虚拟机中可以理解为方法区是标准，永久区是实现
- 类的元信息，对类进行描述
- 方法区是全局共享的，在一定条件下也会被 GC，较少出现。
- 根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。

##### Java堆

- 存放对象实例及数组，所有 new 出来的对象都存储在该区域。
- 应用系统对象都保存在Java堆中 
- 所有线程共享Java堆
- 对分代GC来说，堆也是分代的（新生代、老年代）
- GC的主要工作空间
- 如果在堆没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。

##### Java栈(虚拟机栈)

- 线程私有
- 栈有一系列帧组成（因此Java栈也叫帧栈）
- 帧保存一个方法的局部变量区包含：
  - 参数
  - 局部变量表（编译器可知的各种数据类型（基础类型）、对象引用）
  - 操作数栈
  - 帧数据区
  - 动态链接
  - 操作数
  - 方法出口
  - 正常方法返回以及异常派发机制

  [详情参考《运行时帧栈结构》](https://github.com/a827871781/Java-notes/blob/master/JVM/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%A7%E6%A0%88%E7%BB%93%E6%9E%84.md)
- 每一次方法调用创建一个帧，并压栈 
- 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。

##### 本地方法栈

 **本地方法栈**用于支持 native 方法的执行，存储了每个 native 方法的执行状态。本地方法栈和虚拟机栈他们的运行机制一致，唯一的区别是，虚拟机栈执行 Java 方法，本地方法栈执行 native 方法。在很多虚拟机中（如 Sun 的 JDK 默认的 HotSpot 虚拟机），会将虚拟机栈和本地方法栈一起使用。

Sun HotSpot 虚拟机直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。





![](https://cdn.sinaimg.cn.52ecy.cn/large/005BYqpgly1g47vxp2io1j30nm0asq61.jpg)

#### Java内存模型

- 一个线程有一个工作内存和主存独立

- 工作内存存放主存中变量的值的拷贝

![](https://cdn.sinaimg.cn.52ecy.cn/large/005BYqpgly1g47w7qy2e8j30h708owef.jpg)

1. 当数据从主内存复制到工作存储时，必须出现两个动作：第一，由主内存执行的读（read）操作；第二，由工作内存执行的相应的load操作；当数据从工作内存拷贝到主内存时，也出现两个操作：第一个，由工作内存执行的存储（store）操作；第二，由主内存执行的相应的写（write）操作

2. 每一个操作都是原子的，即执行期间不会被中断 read是不会中断的，但是read和load中间会中断。

3. 对于普通变量，一个线程中更新的值，不能马上反应在其他变量中，如果需要在其他线程中立即可见，需要使用 volatile 关键字，如果工作内存用volatile 关键字修饰的变量修改会通知其他所有线程修改该关键字

![](https://cdn.sinaimg.cn.52ecy.cn/large/005BYqpgly1g47wehya64j30bt0ajwf7.jpg)

**可见性**

- 一个线程修改了变量，其他线程可以立即知道

**保证可见性的方法**

- volatile

- synchronized （unlock之前，写变量值回主存）

- final(一旦初始化完成，其他线程就可见)

#### 解释执行和编译执行的区别

解释运行

- 解释执行以解释方式运行字节码

- 解释执行的意思是：读一句执行一句

编译运行（JIT）

- 将字节码编译成机器码

- 直接执行机器码

- 运行时编译

- 编译后性能有数量级的提升







