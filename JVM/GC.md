### GC

GC的种类

1. 标记清除(老年代)
2. 标记压缩(老年代)
3. 复制算法 (新生代)

#### 垃圾对象检测算法

1. 引用计数法
2. 可达性分析算法

##### 引用计数法

 堆中每个对象（不是引用）都有一个引用计数器。当一个对象被创建并初始化赋值后，该变量计数设置为 1。每当有一个地方引用它时，计数器值就加 1（a = b， b 被引用，则 b 引用的对象计数 + 1）。当引用失效时（一个对象的某个引用超过了生命周期（出作用域后）或者被设置为一个新值时），计数器值就减 1。任何引用计数为 0 的对象可以被当作垃圾收集。当一个对象被垃圾收集时，它引用的任何对象计数减 1。

​    优点：引用计数收集器执行简单，判定效率高，交织在程序运行中。对程序不被长时间打断的实时环境比较有利（OC 的内存管理使用该算法）。

​    缺点： 难以检测出对象之间的循环引用。同时，引用计数器增加了程序执行的开销。

**Java 语言并没有选择这种算法来判断对象是否存活**

##### 可达性分析算法

通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。不可达对象变为可回收对象至少要经过两次标记过程，两次标记过程后仍然是不可达对象，则面临回收。

首先了解一个概念：**根集 (GC roots)**

​    所谓根集就是正在执行的 Java 程序可以访问的引用变量（注意：不是对象）的集合 (包括局部变量、参数、类变量)，程序可以使用引用变量访问对象的属性和调用对象的方法。

​    这种算法的基本思路：

 （1）通过一系列名为 “GC Roots” 的对象作为起始点，寻找对应的引用节点。

 （2）找到这些引用节点后，从这些节点开始向下继续寻找它们的引用节点。

 （3）搜索所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连时，就证明此对象是不可达的。



**在Java语言中，可作为GCRoots的对象包括下面几种：**

1. 虚拟机栈（栈帧中的本地变量表）中引用的对象。
2. 方法区中类静态属性引用的对象。
3. 方法区中常量引用的对象。
4. 本地方法栈中JNI（即一般说的Native方法）引用的对象。

### 引用

在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为：

1. 强引用（Strong Reference）

2. 软引用（Soft Reference）
3. 弱引用（Weak Reference）
4. 虚引用（Phantom Reference）

**[引用详情可以查看《引用》](https://github.com/a827871781/Java-notes/blob/master/JVM/%E5%BC%95%E7%94%A8.md)**


### GC算法

#### 1. 标记清除

为了解决引用计数法的问题而提出。它使用了根集的概念，它分为 “标记” 和 “清除” 两个阶段：首先标记出所需回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实就是前面的根搜索算法中判定垃圾对象的标记过程。

​    优点：不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效。

​      缺点：（1）**标记和清除过程的效率都不高。**（这种方法需要使用一个空闲列表来记录所有的空闲区域以及大小。对空闲列表的管理会增加分配对象时的工作量。如图 4.1 所示。）。（2）**标记清除后会产生大量不连续的内存碎片。**虽然空闲区域的大小是足够的，但却可能没有一个单一区域能够满足这次分配所需的大小，因此本次分配还是会失败（在 Java 中就是一次 OutOfMemoryError）不得不触发另一次垃圾收集动作。

#### 2. 标记压缩

标记-压缩算法适合用于存活对象较多的场合，如老年代。它在标记-清除算法的基础上做了一些优化。和标记-清除算法一样，标记-压缩算法也首先需要从根节点开始，对所有可达对象做一次标记。但之后，它并不简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。

优点： 可有效利用堆。相对于 GC 复制 - 清除，GC 标记 - 压缩不会空出一个 To 空间，是利用了整个堆。相对于 GC 标记 - 清除，GC 标记 - 压缩对活动对象进行了压缩，不存在碎片化的问题，所以有效率利用率高。

缺点：压缩花费计算成本大。为了对活动对象进行压缩，我们看到 Lisp2 的压缩过程必须进行三次堆搜索。堆搜索的花费时间是和堆的大小成正比的，所以 GC 标记 - 压缩算法的吞吐量要劣于其它算法。在 GC 标记 - 清除算法中，清除阶段也要搜索整个堆，不过搜索一次就够了。但 GC 标记 - 压缩要搜索三次，这样就要花费大约三倍的时间，这是一个相当巨大的缺陷，特别是堆越大，所消耗的成本也越大。

#### 3. 复制算法

为了克服句柄的开销和解决堆碎片的垃圾回收。它将内存按容量分为大小相等的两块，每次只使用其中的一块（对象面），当这一块的内存用完了，就将还存活着的对象复制到另外一块内存上面（空闲面），然后再把已使用过的内存空间一次清理掉。

​      复制算法比较适合于新生代（短生存期的对象），在老年代（长生存期的对象）中，对象存活率比较高，如果执行较多的复制操作，效率将会变低，所以老年代一般会选用其他算法，如标记 — 整理算法。一种典型的基于 Coping 算法的垃圾回收是 stop-and-copy 算法，它将堆分成对象区和空闲区，在对象区与空闲区的切换过程中，程序暂停执行。

​      优点：（1）标记阶段和复制阶段可以同时进行。（2）每次只对一块内存进行回收，运行高效。（3）只需移动栈顶指针，按顺序分配内存即可，实现简单。（4）内存回收时不用考虑内存碎片的出现（得活动对象所占的内存空间之间没有空闲间隔）。

​      缺点：需要一块能容纳下所有存活对象的额外的内存空间。因此，可一次性分配的最大内存缩小了一半。

虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次**Minor GC**后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（**默认为15岁**），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:Max TenuringThreshold设置。

#### 4.分代收集算法

根据对象的存活周期不同将内存划分为新生代和老年代，存活周期短的为新生代，存活周期长的为老年代。这样就可以根据每块内存的特点采用最适当的收集算法。
新生代的中每次垃圾收集中会发现有大批对象死区，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集，**复制算法**。

老年代中因为对象的存活率高，没有额外的控件对它进行分配担保，就必须使用 “**标记 - 清扫**” 或者 “**标记 - 整理**” 算法来进行回收。



#### GC时为什么会有全局停顿？

– 类比在聚会时打扫房间，聚会时很乱，又有新的垃圾产生，房间永远打扫不干净，只有让大家停止活动了，才能将房间打扫干净。

**危害**

– 长时间服务停止，没有响应

– 遇到HA系统（双机集群），可能引起主备切换，严重危害生产环境。

### JVM 的 YGC&FGC

YGC( young gc) ：对新生代堆进行 GC。频率比较高，因为大部分对象的存活寿命较短，在新生代里被回收。性能耗费较小。

FGC (full gc)：全堆范围的 GC。默认堆空间使用到达 80%(可调整) 的时候会触发 FGC。以我们生产环境为例，一般比较少会触发 FGC，有时 10 天或一周左右会有一次。

### 什么时候会触发 YGC, 什么时候触发 FGC?

#### YGC 触发的条件:

edn 空间不足

#### FGC 触发的条件

除 外，触发 Full GC 执行的情况有如下四种。

1. 老年代空间不足
2. 方法区空间满 （1.8后 改为Metaspace 元数据区 扩容到 -XX:MetaspaceSize 参数指定的量，就会发生 FGC）
3. 直接调用 System.gc

  

