## 运行时帧栈结构

### 栈帧（Stack Frame）

用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素，栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。

在**编译程序代码的时候**，栈帧中需要多大的局部变量表，**多深的操作数栈**都已经完全**确定**了。

因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。

**在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法。**

![帧栈.png](https://i.loli.net/2019/07/22/5d3563b05016b77187.png)

#### 局部变量表

​	局部变量表（Local Variable Table）是一组变量值存储空间，用于存放**方法参数**和**方法内部定义的局部变量**。并且在 Java 编译为 Class 文件时，就已经确定了该方法所需要分配的局部变量表的最大容量。

​	局部变量表的容量以**变量槽（Slot）为最小单位**，32 位虚拟机中一个 Slot 可以存放一个 32 位以内的数据类型（boolean、byte、char、short、int、float、reference （引用类型）和 returnAddress 八种）。

 	reference 类型虚拟机规范没有明确说明它的长度，但一般来说，虚拟机实现至少都应当能从此引用中直接或者间接地查找到对象在 Java 堆中的起始地址索引和方法区中的对象类型数据。

​      returnAddress 类型是为字节码指令 jsr、jsr_w 和 ret 服务的，它指向了一条字节码指令的地址。

​      虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果是实例方法（非 static），那么局部变量表的第 0 位索引的 Slot 默认是用于传递方法所属对象实例的引用，在方法中通过 this 访问。

​	Slot 是可以重用的，当 Slot 中的变量超出了作用域，那么下一次分配 Slot 的时候，将会覆盖原来的数据。Slot 对对象的引用会影响 GC（要是被引用，将不会被回收）。

 	系统不会为局部变量赋予初始值（实例变量和类变量都会被赋予初始值）。也就是说不存在类变量那样的准备阶段。

​	由于局部变量表存在栈帧中。所以，如果函数参数和局部变量比较多，会使的局部变量表膨胀，每一次调用会占用更多的栈空间。最终结局就是栈空间内存一定的情况下调用的次数减少。

​	递归就很容易引起栈内存溢出(**StackOverFlowError** )异常

#### 操作数栈

​	Java 虚拟机的解释执行引擎被称为 "基于栈的执行引擎"，其中所指的栈就是指－**操作数栈**。

​	和局部变量区一样，操作数栈也是被组织成一个以字长为单位的数组。但是和前者不同的是，它不是通过索引来访问，而是通过标准的栈操作 — 压栈和出栈 — 来访问的。比如，如果某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用。

​      虚拟机在操作数栈中存储数据的方式和在局部变量区中是一样的：如 int、long、float、double、reference 和 returnType 的存储。对于 byte、short 以及 char 类型的值在压入到操作数栈之前，也会被转换为 int。

​      虚拟机把操作数栈作为它的工作区 —— 大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。比如，iadd 指令就要从操作数栈中弹出两个整数，执行加法运算，其结果又压回到操作数栈中，看看下面的示例，它演示了虚拟机是如何把两个 int 类型的局部变量相加，再把结果保存到第三个局部变量的：

```java
begin  
iload_0    // 将存储在局部变量中索引为 0  的整数压入操作数栈中 
iload_1    // 将存储在局部变量中索引为 1  的整数压入操作数栈中 
iadd       // iadd 指令从操作数栈中弹出那两个整数相加,再将结果压入操作数栈
istore_2   // 从操作数栈中弹出结果，并把它存储到局部变量区索引为 2 的位置  
end  
```
![压栈.png](https://i.loli.net/2019/07/22/5d35596347dae49222.png)

#### 动态连接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。

Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数，在类加载阶段中的解析阶段会将符号引用转为直接引用，这种转化也称为静态解析。另外的一部分将在每一次运行时期转化为直接引用。这部分称为动态连接。

#### 方法返回地址

当一个方法被执行后，有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者 (调用当前方法的的方法称为调用者)，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法方式称为正常完成出口 (Normal Method Invocation Completion)。
   另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是 Java 虚拟机内部产生的异常，还是代码中使用 athrow 字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方式称为异常完成出口 (Abrupt Method Invocation Completion)。一个方法使用异常完成出口的方式退出，是不会给它的调用都产生任何返回值的。
   无论采用何种方式退出，在方法退出之前，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者 PC 计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。
   方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值 (如果有的话) 压入调用都栈帧的操作数栈中，调用 PC 计数器的值以指向方法调用指令后面的一条指令等。

#### 附加信息

虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与高度相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其它附加信息全部归为一类，称为栈帧信息。

![帧栈详情.png](https://i.loli.net/2019/07/22/5d3563a7b3a1a89904.png)