### 类加载

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization），这 5个阶段一般是顺序发生的，但在动态绑定的情况下，解析阶段发生在初始化阶段之后。

#### 如果类没有进行过初始化，以下行为能触发其初始化。

- new关键字实例化对象
- 读取或设置一个类的静态字段（非final字段）
- 调用一个类的静态方法
- java.lang.reflect包的方法对类进行反射调用
- 初始化子类时，必先初始化其父类
- 虚拟机先初始化Main方法所在类

#### 类加载的过程

1. 加载（Loading）
   - 将字节码从不同的数据源（可能是 class 文件、jar 包、网络、运行时计算生成（动态代理）等）转化为二进制字节流加载到内存中
   - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
   - 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据

2. 验证（Verification）
   JVM 会在该阶段对二进制字节流进行校验，只有符合 JVM 字节码规范的才能被 JVM 正确执行。该阶段是保证 JVM 安全的重要屏障，下面是一些主要的检查。
   - 确保二进制字节流格式符合预期（比如说是否以 `cafe bene` 开头）。
   - 是否所有方法都遵守访问控制关键字的限定。
   - 方法调用的参数个数和类型是否正确。
   - 确保变量在使用之前被正确初始化了。
   - 检查变量是否被赋予恰当类型的值。

3. 准备（Preparation）
   JVM 会在该阶段对类变量（也称为静态变量，`static` 关键字修饰的）分配内存并初始化（对应数据类型的默认初始值，如 0、0L、null、false 等）。

   | 数据类型  | 默认初始值 |
   | :-------: | :--------: |
   |    int    |     0      |
   |   long    |     0L     |
   |  boolean  |   false    |
   |   float   |    0.0f    |
   |   short   | （short）0 |
   |  double   |    0.0d    |
   |   char    |   u0000    |
   | reference |    null    |
   |   byte    | （byte）0  |

4. 解析（Resolution）
   该阶段将常量池中的符号引用转化为直接引用。
   **符号引用**以一组符号（任何形式的字面量，只要在使用时能够无歧义的定位到目标即可）来描述所引用的目标。

   **直接引用**通过对符号引用进行解析，找到引用的实际内存地址。

5. 初始化（Initialization）

   该阶段是类加载过程的最后一步。在准备阶段，类变量已经被赋过默认初始值，而在初始化阶段，类变量将被赋值为代码期望赋的值。换句话说，初始化阶段是执行**类构造器方法**的过程。

#### 类加载器

 类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，**即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等**。（此处相等包括：equels方法，isAssignableFrom 方法，isInstance方法，instanceof关键字等）

##### 从Java虚拟机的角度来讲，只存在两种不同的类加载器：

1. 启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分
2. 所有其他的类加载器，这些加载器都由Java语言实现，独立于虚拟机外部，并且全部都继承自抽象类java.lang.ClassLoader

##### 从Java开发人员角度来看，类加载器可以为三种：

1. 启动类加载器（Bootstrap Class-Loader），加载 `jre/lib` 包下面的 jar 文件，比如说常见的 rt.jar。
2. 扩展类加载器（Extension or Ext Class-Loader），加载 `jre/lib/ext` 包下面的 jar 文件。
3. 应用类加载器（Application or App Class-Loader），也称系统类加载器，根据程序的类路径（classpath）来加载 Java 类。

#### 双亲委派模型

**双亲委派模型**：如果一个类加载器收到了加载类的请求，它会先把请求委托给上层加载器去完成，上层加载器又会委托上上层加载器，一直到最顶层的类加载器；如果上层加载器无法完成类的加载工作时，当前类加载器才会尝试自己去加载这个类。

![类加载器层次](http://tva1.sinaimg.cn/large/0060lm7Tly1g4y8wghte7j30b90bv3yh.jpg)

图中展示的类加载器之间的这种层次关系，就是类加载器的双亲委派模型（Parents Delegation Model）。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。

使用双亲委派模型有一个很明显的好处，那就是 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系，这对于保证 Java 程序的稳定运作很重要，并能够保证同一个类最终会被特定的类加载器加载。







   

   

   

   

   

   

   

   

   

   