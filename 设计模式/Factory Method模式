# `方法工厂模式

```java
/**
 *工厂抽象类
 */
public abstract class Factory {
    public final  Product create(String  name){
        Product p = createProduct(name);
        registerProduct(p);
        return p ;
    }
    protected  abstract void registerProduct( Product p) ;
    protected  abstract Product createProduct( String  name) ;
}
/**
 *工厂A实例
 */
public  class AFactory extends  Factory {
    @Override
    protected   void registerProduct( Product p){
        p.use();
    }
    @Override
    protected   Product createProduct( String  name) {
         return   new AProduct(name);
    }
}
/**
 *工厂B实例
 */
public  class BFactory extends  Factory {
    @Override
    protected   void registerProduct( Product p){
        p.use();
    }
    @Override
    protected   Product createProduct( String  name) {
         return   new BProduct(name);
    }
}
/**
 *产品抽象类
 */
public abstract class Product {
    public abstract void use();
}
/**
 *产品实例A
 */
public  class AProduct extends Product {
    private String  name ;

    public AProduct(String name) {
        this.name = name;
    }
    @Override
    public  void use(){
        System.out.println("use"+ name + "A");
    }
}
/**
 *产品实例B
 */
public  class BFactory extends  Factory {
    @Override
    protected   void registerProduct( Product p){
        p.use();
    }
    @Override
    protected   Product createProduct( String  name) {
         return   new BProduct(name);
    }
}
public class Main {
    public static void main(String[] args) {
//        Factory factory = new AFactory();
        Factory factory = new BFactory();
        Product product = factory.create("张三");
    }
}

```

# 使用场景

1. 把对象的创建和使用的过程分开，对使用者屏蔽了具体细节，使用者只需要调用具体的创建方法即可
2. 降低代码重复，用到了方法模板模式
3. 隐藏具体产品实例，如果后期更改其他实例，对于调用者而言，完全隐藏，调用者不需要更改代码。

## 总结


1. 一个抽象产品类，可以派生出多个具体产品类。   
4. 一个抽象工厂类，可以派生出多个具体工厂类。   
5. 将类的实例化（具体产品的创建）延迟到工厂类的子类（具体工厂）中完成，即由子类来决定应该实例化（创建）哪一个类。

## 源码使用场景

Spring Ioc 容器 创建bean