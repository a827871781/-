#### 两者的共同点：

-   协调多线程对共享对象、变量的访问
-   可重入，同一线程可以多次获得同一个锁
-   都保证了可见性和互斥性

#### 两者的不同点：

|                |                      synchronized                      |          ReentrantLock           |
| :------------- | :----------------------------------------------------: | :------------------------------: |
| 种类           |                java 语言关键字/JVM 级别                |         一个类/API 级别          |
| 用法           |                     隐式获得释放锁                     |         显示获得、释放锁         |
| 作用范围       |                可用于修饰方法、代码块等                |         只适用于代码块锁         |
| 特性           | 不可以响应中断的，为处理锁的不可用性提供了更高的灵活性 |        可响应中断、可轮回        |
| 公平锁         |                           ×                            |                √                 |
| 锁绑定多个条件 |                           ×                            |                √                 |
| 底层实现       |             同步阻塞，采用的是悲观并发策略             | 同步非阻塞，采用的是乐观并发策略 |

#### 适用场景:

Synchronized : 在资源竞争不是很激烈的情况下，偶尔会有同步的情形下，synchronized 是很合适的。原因在于，编译程序通常会尽可能的进行优化

ReentrantLock : 当同步非常激烈的时候，还能维持常态。所以比较适合高并发的场景。

但是推荐用 Synchronized 关键字,如果有业务场景是需要用lock 的特性的需求,那么再考虑用lock,或者需要优化时.再采用lock.