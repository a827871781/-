### 1、java程序执行步骤

1. javac编译器将源代码编译成字节码。
2. jvm类加载器加载字节码文件
3. 解释器逐行解释执行
4. 程序运行过程中部分热点代码可以通过**JIT**编译成机器码(不是逐行)并存在缓存里(运行时编译保证了可移植性)，下次运行可以直接从缓存里取机器码，效率更高。
5. **AOT**直接将字节码编译成机器代码，这样就避免了 JIT 预热等各方面的开销。

#### AOT:指运行前编译

优点：

1. 在程序运行前编译，可以避免在运行时的编译性能消耗和内存消耗
2. 可以在程序运行初期就达到最高性能
3. 可以显著的加快程序的启动

缺点：

1. 在程序运行前编译会使程序安装的时间增加
2. 牺牲 Java 的一致性
3. 将提前编译的内容保存会占用更多的外存

#### JIT:动态 (运行时) 编译

优点：

1. 可以根据当前硬件情况实时编译生成最优机器指令（ps. AOT 也可以做到，在用户使用是使用字节码根据机器情况在做一次编译）
2. 可以根据当前程序的运行情况生成最优的机器指令序列
3. 当程序需要支持动态链接时，只能使用 JIT
4. 可以根据进程中内存的实际情况调整代码，使内存能够更充分的利用

缺点：

1. 编译需要占用运行时资源，会导致进程卡顿
2. 由于编译时间需要占用运行时间，对于某些代码的编译优化不能完全支持，需要在程序流畅和编译时间之间做权衡
3. 在编译准备和识别频繁使用的方法需要占用时间，使得初始编译不能达到最高性能

Java 是**解释和编译**混合的一种模式

解释执行/编译执行区别

解释执行：类似同声传译，没有提前准备，看到一行解释一行。运行时效率一般。

编译执行：类似录音机 ，提前编译、优化，直接执行，运行时效率高，但是需要编译。

### 2、Exception和Error区别

Exception 和 Error 都是继承了 Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（ throw ）或者捕获（ catch ），它是异常处理机制的基本组成类型。

#### Exception 和 Error 体现了 Java 平台设计者对不同异常情况的分类：

- Exception 是程序正常运行中，可以预料的意外情况，也就是要么捕获异常并作出处理，要么继续抛出异常。
- Error 是指在正常情况下，不大可能出现的情况，系统错误，虚拟机出错，我们处理不了，也不需要我们来处理。绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。

#### Exception又分为 可检查 （checked）异常和 不检查 （unchecked）异常:

- 可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。
- 不检查异常就是所谓的运行时异常，类似 NullPointerException 、 ArrayIndexOutOfBoundsException 之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。

![T.png](https://i.loli.net/2019/07/18/5d3045ebd844550122.png)

#### 异常处理原则

- 尽量不要捕获类似Exception这样的通用异常，而是应该捕获特定异常 ，如：Thread.sleep()抛出的InterruptedException。
- 不要仅仅捕获异常而不做任何处理，不便于将来维护
- 不要在fnally代码块中处理返回值。
- 函数返回值有两种类型：值类型与对象引用。对于对象引用，要特别小心，如果在fnally代码块中对函数返回的对象成员属性进行了修改，即使不在fnally块中显式调用return语句，这个修改也会作用于返回值上。
- 抛出异常时需要针对具体问题来抛出异常，抛出的异常要足够具体详细。
- 在捕获异常时需要对捕获的异常进行细分，这时会有多个 catch 语句块，这几个 catch 块中间泛化程度越低的异常需要越放在前面捕获，泛化程度高的异常捕获放在后面，这样的好处是如果出现异常可以近可能得明确异常的具体类型是什么
- try-catch代码段会产生额外的性能开销，或者换个角度说，它往往会影响JVM对代码进行优化，所以建议仅捕获有必要的代码段，尽量不要一个大的try包住整段的代码；与此同时，利用异常控制代码流程，也不是一个好主意，远比我们通常意义上的条件语句（ if/else 、 switch ）要低效。
- Null 的判断逻辑并不是一成不变的，当方法允许返回 null 的时候使用 if-else 控制逻辑，否则就抛出 NullPointerException
- 定义你自己的异常类层次，例如 UserException 和 SystemException 分别代表用户级别的异常信息和系统级别的异常信息，而其他的异常在这两个基类上进行扩展

### 3、谈谈final、finally、 finalize有什么不同？

**final** 可以用来修饰类、方法、变量，分别有不同的意义， final修饰的 class 代表不可以继承扩展， final的变量是不可以修改的，而 final的方法也是不可以重写的（ override ）。
**finally** 则是 Java 保证重点代码一定要被执行的一种机制。我们可以使用 try-finally或者 try-catch-finally来进行类似关闭 JDBC 连接、保证 unlock 锁等动作。
**finalize** 是基础类 java.lang.Object 的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。 finalize机制现在已经**不推荐使用**，并且在 JDK 9 开始被标记为 deprecated 。

以下情况finally不会执行：

```java
//1. try-cach 异常退出。
try{
    system.exit(1)
}fnally{
	print(1)
}
//2. 无限循环
try{
    while(ture){
   		 print(1)
    }
}fnally{
	print(2)	
}
//3. 线程被杀死
//当执行 try，finally 的线程被杀死时。finally 也无法执行。

```

不要在 finally中使用 return 语句。使用不当可能会导致返回结果不可控

finalize代替方案 ：虚引用 + 引用队列

### 4、Java的对象引用

Java中根据其生命周期的长短，将引用分为4类。

1. 强引用（死都不清）
    特点：我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足，JVM会抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了。

2.  软引用（满了才清）
    特点：软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象：即JVM 会确保在抛出 OutOfMemoryError之前，清理软引用指向的对象。
    应用场景：一般用于做缓存。

3. 弱引用（一次就清）
    弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。
    应用场景：也可以用于做缓存。

4.  虚引用（跟本没有）
    特点：虚引用也叫幻象引用，通过PhantomReference类来实现。无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 fnalize 以后，做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。

    ```java
    ReferenceQueue queue = new ReferenceQueue ();
    PhantomReference pr = new PhantomReference (object, queue);
    ```

    程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取一些程序行动。
    应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。