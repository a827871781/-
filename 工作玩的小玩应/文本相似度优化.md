智能匹配相似度查询优化,

初始设计,java定时任务 调用js代码 计算 已有数据 的相似度,存储redis内,以供查询使用.

缺陷: redis 内数据量 为 已有数据条数的平方,当数据超过5000条时,redis已经存储超过百万级数据,在大数据量的情况下,redis表现不佳.

redis 占用大量内存.新增数据无法第一时间获取相似度,得第二天才可以看到.

优点:数据量 不大的情况下,查询效率一直高效.相似度算法可以更精准.

优化方案

已知数据是从数据库中多个表内,四个text类型字段 (参考治疗方案,矫治设计目标,风险提示,原因说明) 推测文本长度,预计可以超过5000字符.

通过比较得知simhash 算法 在大文本计算时,表现更佳.故此文本相似度算法选型为simhash

simhash 和余弦相似度计算相似度的时间：

| 字符数 | simhash 耗时 /ms | 余弦相似度耗时 /ms |
| ------ | ---------------- | ------------------ |
| 20     | 1.7              | 0.4                |
| 200    | 4.2              | 1.8                |
| 2000   | 20.0             | 10.7               |
| 20000  | 24.1             | 34.0               |
| 200000 | 176.7            | 668.5              |

余弦相似度对于短文本的相似度计算还是比较准确的，但是对于大文本计算时，速度不如 simhash 快。

对比时,采用多线程方案进行对比.在Fork/Join  和 并行流 中选择了 并行流,理由是 在 收集到的数据中,发现并发流 只有在系统内部执行其他多线程程序时变现不如 Fork/Join ,其他情况基本都优于 Fork/Join ,且 并行流,所需代码量少,错误就会更少.

最终设计为:

实时通过并行流计算文本相似度.  + redis 缓存 该数据与其他数据的相似度,新增数据时,将redis 内存储的 key 查询并遍历对比后,存入redis即可.

缺点,第一次某条数据相似度相对较慢,大约需要10S左右,再次进行查询即可实现秒级.部分数据文本长度过短,相似度计算可能相对不太准确.

优点,更多的数据存储,相对更快的查询速度.实时查询.

